{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"stm32学习\" category",
    "description": "欢迎大家来到邦的轩辕的小屋，这里会分享everything",
    "home_page_url": "https://bangdexuanyuan.github.io",
    "items": [
        {
            "id": "https://bangdexuanyuan.github.io/stm32/EXTI%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/",
            "url": "https://bangdexuanyuan.github.io/stm32/EXTI%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/",
            "title": "EXTI外部中断",
            "date_published": "2023-09-02T16:21:00.000Z",
            "content_html": "<p>NVIC 的名字叫做，嵌套中断向量控制器</p>\n<p>NVIC 的出现，就是为了当 CPU 的秘书，如果我们把所有的中断都接在 CPU 上，CPU 对应位置就得进行适配，设计上就很麻烦。并且如果很多中断进行申请，造成了拥堵，CPU 也会很难搞，因为 CPU 还是主要负责进行运算的，中断分配的任务就放到别的地方吧。</p>\n<p>NVIC 有很多个输入口，你有多少个中断都可以接过来</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/64f35828661c6c8e54dee9d2.png\" alt=\"\"></p>\n<p>NVIC 只有一个输出口，直接接到 CPU 上</p>\n<p>stm32 有 68 个可屏蔽中断通道，包含 EXTI、TIM、ADC、USART、SPI、I2C、RTC 等多个外设使用 NVIC 统一管理中断，每个中断通道都拥有 16 个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级</p>\n<p>NVIC 的中断优先级由优先级寄存器的 4 位（0~15）决定，这 4 位可以进行切分，分为高 n 位的抢占优先级和低 4-n 位的响应优先级，记住，值越小的优先级越高，比如 0 就是最高的优先级</p>\n<p>抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，<strong>抢占优先级和响应优先级均相同的按中断号排队</strong></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/64f35a2d661c6c8e54df3a92.png\" alt=\"\"></p>\n<p>举个例子，就好像是有个医生在给一个人进行看病，抢占优先级高的可以直接把看病的那个人挤开，让自己去看。然后响应优先级就好像是有个人排队，他就应该排在第一位，大概就是这个意思。</p>\n<hr>\n<p>综上所述，现在我们可以这么理解，NVIC 其实可以理解成为一个叫号系统，而 CPU 就是那个医生，下面我们来介绍第一位病人，EXTI 外部中断</p>\n<hr>\n<p>EXTI（Extern Interrupt）外部中断</p>\n<p>EXTI 可以监测指定 GPIO 口的电平信号，当其指定的 GPIO 口产生电平变化时，EXTI 将立即向 NVIC 发出中断申请，经过 NVIC 裁决后即可中断 CPU 主程序，使 CPU 执行 EXTI 对应的中断程序</p>\n<p>支持的触发方式：上升沿 / 下降沿 / 双边沿 / 软件触发</p>\n<p><strong>解释一下</strong>：这里的上升沿是指由低电平上升到高电平，下降沿是由高电平降低到低电平，而双边沿就是指上下都计数</p>\n<p>支持的 GPIO 口：所有 GPIO 口，但相同的 Pin 不能同时触发中断</p>\n<p>通道数：16 个 GPIO_Pin，外加 PVD 输出、RTC 闹钟、USB 唤醒、以太网唤醒</p>\n<p>触发响应方式：中断响应 / 事件响应</p>\n<h4 id=\"首先介绍一下exti的基本结构\"><a class=\"markdownIt-Anchor\" href=\"#首先介绍一下exti的基本结构\">#</a> 首先介绍一下 EXTI 的基本结构</h4>\n<p><img data-src=\"https://pic.imgdb.cn/item/64f355a9661c6c8e54de9017.png\" alt=\"\"></p>\n<p>这里的每个 GPIO 都有 16 个引脚，显然对于只有 16 个输入口的 EXT 是远远超出的，所以我们中间加一个 AFIO 中断引脚选择器，你可以理解为 GPIOA，B，C 共用一个 Pin 引脚口，那么就可以解释了，为什么相同的引脚不能同时触发中断，因为这样，你根本不知道是哪个 GPIO 口发生了中断。</p>\n<p>经过 EXTI 后，分为了两种输出，一种直接接到 NVIC，一种接入其他外设。</p>\n<p>根据常理，本来 20 种的中断输入应该有 20 种的中断输出，但是可能是 STM 公司觉得有点占用 NVIC 的通道，于是，将 EXTI5~9， EXTI10~15 分别合并为了一种通道， 也就是说 EXTI5~9 会触发同一种中断函数，同理 10 到 15 也是</p>\n<p>对于合并通道的中断函数，还需根据标志位进一步确定这个是由哪个中断函数进来的</p>\n<h4 id=\"afio复用io口\"><a class=\"markdownIt-Anchor\" href=\"#afio复用io口\">#</a> AFIO 复用 IO 口</h4>\n<p>AFIO 主要用于引脚复用功能的选择和重定义，在 STM32 中，AFIO 主要完成两个任务：复用功能引脚重映射、中断引脚选择。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/64f360b1661c6c8e54e160f5.png\" alt=\"\"></p>\n<p>这就是 AFIO 的作用</p>\n<p>程序部分</p>\n<p>首先在 Hardware 文件夹中新建 CountSensor.h 和 CountSensor.c 文件</p>\n",
            "tags": [
                "stm32"
            ]
        },
        {
            "id": "https://bangdexuanyuan.github.io/stm32/%E5%9B%BA%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "url": "https://bangdexuanyuan.github.io/stm32/%E5%9B%BA%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "title": "stm32定时器外设时钟",
            "date_published": "2023-09-02T07:28:00.000Z",
            "content_html": "<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">RCC_AHBPeriphClockCmd</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uint32_t</span> RCC_AHBPeriph<span class=\"token punctuation\">,</span> FunctionalState NewState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">RCC_APB2PeriphClockCmd</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uint32_t</span> RCC_APB2Periph<span class=\"token punctuation\">,</span> FunctionalState NewState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">RCC_APB1PeriphClockCmd</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uint32_t</span> RCC_APB1Periph<span class=\"token punctuation\">,</span> FunctionalState NewState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>定时器函数</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210427151456665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjI5NTYz,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<p>void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);</p>\n<p>NewState 参数是一个枚举类型，用于指示要使能或禁用指定的外设时钟。可选值为：ENABLE 和 DISABLE。</p>\n<p><strong>例 1-1</strong>：以下代码片段用于使能 GPIOA 和 USART1 外设的时钟：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);</pre></td></tr></table></figure><p>在操作外设之前，必须先使能其时钟。</p>\n<h3 id=\"2-引脚配置\"><a class=\"markdownIt-Anchor\" href=\"#2-引脚配置\">#</a> 2、引脚配置</h3>\n<p>GPIO_InitTypeDef 结构体是 STM32 固件库中提供给开发者的一个方便、易用的工具，当我们要配置一个 GPIO 引脚时，需要设置该引脚的多个参数，如引脚方向、输出类型、速度、上拉 / 下拉模式等，这些参数需要通过寄存器进行设置。而寄存器的操作比较繁琐，容易出错，因此 STM32 固件库提供了 GPIO_InitTypeDef 结构体，它封装了对 GPIO 外设寄存器的访问，使得开发者可以通过设置结构体的成员变量，来快速、简单地配置 GPIO 引脚的多个参数。</p>\n<p>先配置 GPIO_InitTypeDef 结构体；结构体的定义如下：</p>\n<p>这个是已经配置好的模式</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>typedef struct</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>&#123;</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  uint16_t GPIO_Pin;             /*!&lt; Specifies the GPIO pins to be configured.</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>                                      This parameter can be any value of @ref GPIO_pins_define */</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  GPIOSpeed_TypeDef GPIO_Speed;  /*!&lt; Specifies the speed for the selected pins.</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  GPIOMode_TypeDef GPIO_Mode;    /*!&lt; Specifies the operating mode for the selected pins.</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>                                      This parameter can be a value of @ref GPIOMode_TypeDef */</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>&#125;GPIO_InitTypeDef;</pre></td></tr></table></figure><p>GPIO_Pin 表示要配置的 GPIO 引脚，可以使用逻辑或运算符 “|” 将多个引脚组合在一起。</p>\n<p>GPIO_Mode 表示 GPIO 引脚的工作模式。</p>\n<table>\n<thead>\n<tr>\n<th>输入</th>\n<th></th>\n<th>输出</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GPIO_Mode_AIN</td>\n<td>模拟输入</td>\n<td>GPIO_Mode_Out_OD</td>\n<td>普通开漏输出</td>\n</tr>\n<tr>\n<td>GPIO_Mode_IN_FLOATING</td>\n<td>浮空输入</td>\n<td>GPIO_Mode_Out_PP</td>\n<td>普通推挽输出</td>\n</tr>\n<tr>\n<td>GPIO_Mode_IPU</td>\n<td>上拉输入</td>\n<td>GPIO_Mode_AF_OD</td>\n<td>复用推挽输出</td>\n</tr>\n<tr>\n<td>GPIO_Mode_IPD</td>\n<td>下拉输入</td>\n<td>GPIO_Mode_AF_PP</td>\n<td>复用开漏输出</td>\n</tr>\n</tbody>\n</table>\n<p>GPIO_Speed 表示 GPIO 引脚的速度，可选值为低速（GPIO_Speed_2MHz）、中速（GPIO_Speed_10MHz）或高速（GPIO_Speed_50MHz）。</p>\n<p>一般默认为普通推挽输出</p>\n<p>** 例 2-1：** 将 PA0 和 PA1 两个引脚配置为 50MHz 的推挽输出，并应用于 GPIOA 外设。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>GPIO_InitTypeDef GPIO_InitStructure<span class=\"token punctuation\">;</span><span class=\"token comment\">// 这个 GPIO_InitStructure 就是一个结构体的名称，你也可以改为 u, 然后后面的名称对应都变成 u 就行</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>GPIO_InitStructure<span class=\"token punctuation\">.</span>GPIO_Pin <span class=\"token operator\">=</span> GPIO_Pin_0 <span class=\"token operator\">|</span> GPIO_Pin_1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>GPIO_InitStructure<span class=\"token punctuation\">.</span>GPIO_Mode <span class=\"token operator\">=</span> GPIO_Mode_Out_PP<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>GPIO_InitStructure<span class=\"token punctuation\">.</span>GPIO_Speed <span class=\"token operator\">=</span> GPIO_Speed_50MHz<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">GPIO_Init</span><span class=\"token punctuation\">(</span>GPIOA<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>GPIO_InitStructure<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>以上代码将 GPIOA 的 PA0 引脚输出低 / 高电平，即将 PA0 引脚对应的寄存器的输出位设置为 0/1。</p>\n<p>注意：在操作 GPIO 引脚之前，必须先配置其为输出模式。否则，GPIO 引脚将不能输出电平。</p>\n<p>* 注意：在很多开发板上，GPIO 输出控制 LED 等外设的亮灭，常常使用了 PNP 型晶体管或是开漏输出方式。这种方式下，当 GPIO 引脚输出低电平时，PNP 型晶体管或是开漏输出器件会通电，外设（如 LED）被点亮，而当 GPIO 引脚输出高电平时，PNP 型晶体管或是开漏输出器件不通电，外设（如 LED）被熄灭。</p>\n",
            "tags": [
                "stm32"
            ]
        },
        {
            "id": "https://bangdexuanyuan.github.io/stm32/stm32%206-1Tim%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/",
            "url": "https://bangdexuanyuan.github.io/stm32/stm32%206-1Tim%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/",
            "title": "定时器学习",
            "date_published": "2023-09-02T02:32:00.000Z",
            "content_html": "<h4 id=\"stm32-6-1tim定时器中断\"><a class=\"markdownIt-Anchor\" href=\"#stm32-6-1tim定时器中断\">#</a> stm32 6-1Tim 定时器中断</h4>\n<p>stm32 拥有 16 位计数器，预分频器，自动重装寄存器的实际单元。如果预分频器和自动重装寄存器都设置最大，2 的 16 次方，因为 2 的 16 次方为 66536</p>\n<p>在 72MHz 计数时钟下可以实现最大 59.65s 的定时</p>\n<p>这部分之后再听一遍</p>\n<p>不仅具有基本的定时中断功能，而且还包括内外时钟源的选择，输入捕获，输出比较，编码器接口，主从触发模式等多种功能</p>\n<p>![](C:\\all study document\\Microcontroller study\\32\\ 图片笔记 \\Snipaste_2023-08-24_22-05-54.png)</p>\n",
            "tags": [
                "单片机"
            ]
        }
    ]
}